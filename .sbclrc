;;; more-or-less tested with both clisp and sbcl. look for PORTABILITY
;;; related things relevant to use on other implementations.

;;; NOTE probably need to
;;;   ln .sbclrc .clisprc.lisp

;;; (progn ... (values)) is another way to prevent the return value from
;;; make-random-state from cluttering up the output
(block nil (setq *random-state* (make-random-state t)) (return))

;;; integer modulus more or less how Perl does it
(defmacro % (a b)
  `(mod (truncate ,a) (truncate ,b)))

;;; also copied from perl as can't remember expt (... but SBCL is very
;;; unhappy about this definition, and CLISP also complains, so leave it
;;; disabled here for reference)
;#+SBCL (sb-ext:unlock-package 'COMMON-LISP)
;(defmacro ** (a b)
;  `(expt ,a ,b))

(defmacro capture-append (file &body body)
  `(with-open-file
     (*standard-output* ,file
                        :direction :output
                        :if-exists :append
                        :if-does-not-exist :create)
     ,@body))

(defmacro capture-clobber (file &body body)
  `(with-open-file
     (*standard-output* ,file
                        :direction :output
                        :if-exists :supersede)
     ,@body))

;;; lazy(?) way to peek at contents of a given file
(defun cat (file)
  (with-open-file (in file)
    (loop for line = (read-line in nil) while line do
          (write-string line)
          (fresh-line))
    (values)))

;;; PORTABILITY just the command line arguments, if any
(defun cli-args ()
  #+CLISP ext:*args*
  #+SBCL (cdr *posix-argv*)    ; nix the program name
; not sure what these give so instead error out if encountered
; #+LISPWORKS system:*line-arguments-list*
; #+CMU extensions:*command-line-words*
  #-(or CLISP SBCL) (error "cli-args unimplemented"))
; tested with:
;   clisp .clisprc.lisp test test 1 2 3
;   sbcl --script .clisprc.lisp test test 1 2 3
;(print (cli-args)) (fresh-line)

;;; Copies text into clipboard
;;;   (clippy "blah")
;;;   (clippy (format nil "~d" (truncate pi)))
;;;
;;; Assuming Mac OS X or that a `pbcopy` command exists that Does The
;;; Right Thing, e.g. perhaps something like
;;;
;;;   #!/bin/sh
;;;   exec xclip -in
;;;
;;; or instead with xsel, or whatever.
(defmacro clippy (this)
  (let ((out (gensym)))
    `(with-open-stream (,out (stream-to-program "pbcopy"))
       (unwind-protect (write-string ,this ,out)
         (close ,out)))))

(defun coinflip () (plusp (random 2)))

(defun date ()
  (multiple-value-bind (ss mm hh day mon year) (get-decoded-time)
    (format nil "~D-~2,'0D-~2,'0D ~2,'0D:~2,'0D:~2,'0D"
            year mon day hh mm ss)))

;;; so one can say things like (frequency nil '(e e e c)) or
;;; (frequency #'length '((a) (b b) (c c c) (d d d)) :test #'equal)
(defun frequency (fn list &key (test #'eql))
  (let ((table (make-hash-table :test test)) (key nil) (value nil) (output nil))
    (dolist (item list)
      (setf key (if (null fn) item (funcall fn item)))
      (setf value (gethash key table))
      (setf (gethash key table) (1+ (if (numberp value) value 0))))
    (maphash #'(lambda (k v) (push (list v k) output)) table)
    (sort output #'< :key #'car)))

;;; reminder: probably want
;;;   (make-hash-table :test 'equal)
;;; as the default test is surprising coming from Perl
;;; PORTABILITY style warning reduction for SBCL
(defun hash-empty (table)
  #+SBCL (declare (sb-ext:muffle-conditions style-warning))
  (maphash #'(lambda (k unused) (remhash k table)) table))

(defun hash-show (table)
  (maphash #'(lambda (k v) (format t "~a => ~a~%" k v)) table))

;;; nixes return value (though there's still a trailing blank line in
;;; `clisp -q -q -x ...` output).
(defmacro no-return (&body body)
  `(progn ,@body (values)))

;;; from Practical Common Lisp (clisp has something named the same, only
;;; with a different interface - (with-gensyms ("PREFIX-" var1 var2) ...))
(defmacro pcl-with-gensyms ((&rest names) &body body)
  `(let ,(loop for n in names collect `(,n (gensym)))
     ,@body))

(defmacro random-list-item (alist)
  `(progn
     (or (listp ,alist)
       (error "random-list-item needs a list to act on"))
     (if (= 0 (list-length ,alist))
       nil
       (nth (random (list-length ,alist)) ,alist))))

;;; ported from my .tclshrc, allows stuff like
;;;   (reduce #'+ (range 2 5))
(defun range (min max &optional (step 1))
  (if (zerop step) (error "step must not be zero"))
  (if (and (< max min) (plusp step)) (setf step (* step -1)))
  (do ((list nil) (op (if (< min max) #'> #'<)))
    ((funcall op min max) (nreverse list))
    (push min list)
    (setf min (+ min step))))

;;; range + reducing lambda so can say
;;;   (rangel 2 5 #'+)
;;; to avoid the generation-of-the-complete-list thing under
;;;   (reduce ... (range ...))
(defmacro rangel (min max step &optional call)
  (let
    ((fn (gensym)) (incr (gensym)) (op (gensym)) (ret (gensym)) (val (gensym)))
    `(progn
       (if (null ,call)
         (progn
           (setf ,fn ,step)
           (setf ,incr 1))
         (progn
           (if (zerop ,step) (error "step must not be zero"))
           (setf ,fn ,call)
           (setf ,incr ,step)))
       (if (and (< ,max ,min) (plusp ,incr)) (setf ,incr (* ,incr -1)))
       (setf ,op (if (< ,min ,max) #'> #'<))
       (setf ,ret ,min)
       (do ((,val (+ ,min ,incr) (+ ,val ,incr))) ((funcall ,op ,val ,max))
         (setf ,ret (funcall ,fn ,ret ,val)))
       ,ret)))

;;; repeat N times doing something(s), e.g.
;;;   (repeat 4 (print "hi"))
;;;   (repeat 4 (print "hi") (print "there"))
(defmacro repeat (count &body body)
  (let ((repnum (gensym)))
    `(progn
       (if (or (not (integerp ,count)) (< ,count 1))
         (error "repeat count must be positive integer"))
       (do ((,repnum ,count (1- ,repnum)))
         ((< ,repnum 1) (return))
         (progn ,@body)))))

(defmacro sethash (hash key &optional (value nil))
  `(setf (gethash ,key ,hash) ,value))

;;; and this form needs a '(key value key2 value2 ...) list.
(defun sethash-fromlist (hash list)
  ; without this guard value of trailing key would be nil, and there
  ; would be no error
  (if (oddp (list-length list)) (error "odd number of elements in list"))
  (loop while list do
        (sethash hash (pop list) (pop list))))

;;; for music related needs. also note the (/= a b) function to check
;;; whether the given values differ or not
(defun sign-of (number)
  (if (minusp number) -1 1))

;;; more PORTABILITY
(defun stream-to-program (prog &rest args)
  #+CLISP (run-program prog
                       :arguments args
                       :input :stream
                       :output nil)
  #+SBCL (sb-ext:process-input
           (sb-ext:run-program prog args
                               :input :stream
                               :output nil
                               :search t
                               :wait nil))
  #-(or CLISP SBCL) (error "run-program unimplemented"))

;;; mostly so I can build a list up from either end; if building a list
;;; only from one end, (push) and then (nreverse) if needed would be
;;; more idiomatic (and efficient).
(defmacro unshift (item place)
  `(progn
     (if (consp ,place)
       (rplacd (last ,place) (cons ,item nil))
       (setf ,place (cons ,item nil)))
     ,place))

;;; as (last vector) barfs with not-a-list
(defmacro vector-last (v) `(elt ,v (1- (length ,v))))
(defmacro vector-index (v) `(1- (length ,v)))

;;; Lisp already has (warn) but I want something similar that emits to
;;; stderr but without the WARNING prefix of (warn). So, copy a C system
;;; call. (reminder: ~& is like (fresh-line) within a format but then
;;; the user would have to remember to use it in their format...)
(defun warnx (format &rest args)
  (format *error-output* format args)
  (fresh-line *error-output*)
  (values))

;;; copying Perl 'while' loop, roughly
(defmacro while (expr &body body)
  `(tagbody check (if ,expr (progn ,@body (go check)))))
